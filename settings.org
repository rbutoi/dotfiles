* Emacs settings

** Loading stuff/setup

#+BEGIN_SRC emacs-lisp
(package-initialize)

(if (eq system-type 'darwin)
    (require 'cask "/usr/local/Cellar/cask/0.7.4/cask.el")
  (if (locate-library "cask") (load-library "cask")
    (require 'cask "~/.cask/cask.el")))
  
(cask-initialize)
(require 'pallet)
(pallet-mode t)

(require 'cl)

(add-to-list 'load-path "~/.emacs.d/lisp/")
(when (locate-library "arista") (load-library "arista"))

(setq custom-file "~/.emacs.d/custom.el")
(when (file-readable-p custom-file) (load custom-file))
#+END_SRC

** UI

*** Theme
#+BEGIN_SRC emacs-lisp
(if window-system
    (progn
      (load-theme 'solarized t)
      (set-frame-parameter nil 'background-mode 'dark)
      (set-terminal-parameter nil 'background-mode 'dark)
      (enable-theme 'solarized)
      (let ((font "Ubuntu Mono-12"))
        (set-face-attribute 'default nil :font font)
        (set-frame-font font nil t))
      ))

;; make window divider prettier
(let ((display-table (or standard-display-table (make-display-table))))
  (set-display-table-slot display-table 'vertical-border (make-glyph-code ?â”‚))
  (setq standard-display-table display-table))

;; a bit more contrast to keep track of curent window
(set-face-attribute  'mode-line
                 nil 
                 :box '(:line-width 3 :style released-button))
(set-face-attribute  'mode-line-inactive
                 nil 
                 :box nil
                 )
(eval-after-load 'hl-line
  (lambda () (set-face-attribute 'hl-line nil :underline t)))
(eval-after-load 'which-func
  (lambda () (set-face-attribute 'which-func nil :foreground "dark cyan")))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/\\1" t)))
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-set-key (kbd "C-c C-r") 'revert-buffer)
(global-auto-revert-mode 1)
(setq vc-follow-symlinks t)
(setq-default save-place t)
(setq save-place-file "~/.emacs.d/saved-places")
(setq recentf-max-saved-items 1000)
(setq recentf-save-file "~/.emacs.d/recentf")
#+END_SRC

*** Buffers and windows
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?o))
(global-set-key (kbd "C-x o") 'ace-window)
(global-set-key (kbd "C-x C-o") 'ace-window)
(defun m-buffer-binds (map)
  (define-key map (kbd "M-o") 'other-window)
  (define-key map (kbd "M-i") (lambda() (interactive) (other-window -1)))
  (define-key map (kbd "M-l")
    (lambda() (interactive) (select-window (get-mru-window t t t))))
  (define-key map (kbd "C-k") 'kill-this-buffer) ; defies name but whatevs

  (define-key map (kbd "M-0") 'delete-window)
  (define-key map (kbd "M-1") 'delete-other-windows)
  (define-key map (kbd "M-2") 'split-window-below)
  (define-key map (kbd "M-3") 'split-window-right)
  (define-key map (kbd "M-=") 'balance-windows))
(m-buffer-binds (current-global-map))
(global-set-key (kbd "C-x C-z") 'zoom-window-zoom)
(setq split-height-threshold nil
      split-width-threshold nil) ; let me split
(global-set-key (kbd "<C-S-up>")     'buf-move-up)
(global-set-key (kbd "<C-S-down>")   'buf-move-down)
(global-set-key (kbd "<C-S-left>")   'buf-move-left)
(global-set-key (kbd "<C-S-right>")  'buf-move-right)
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp
(require 'helm)
(require 'helm-config)

(setq helm-buffer-max-length 30)
(setq helm-buffer-skip-remote-checking t)
(setq helm-split-window-default-side 'same)

(setq helm-grep-default-command
      "ack -Hn --color --smart-case --no-group %p %f"
      helm-grep-default-recurse-command
      "ack -H --color --smart-case --no-group %p %f")
(setq helm-ag-base-command "ack --nocolor --nogroup --smart-case")
(setq helm-ag-insert-at-point 'word)
(global-set-key (kbd "C-M-s")
                (lambda (&optional arg) (interactive "P")
                    (if arg
                        (helm-do-ag)
                      (helm-do-ag default-directory))
                    ))

(global-set-key (kbd "C-c h") 'helm-command-prefix)
(define-key helm-map (kbd "C-k") 'helm-execute-persistent-action)
(global-unset-key (kbd "C-x c"))
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-m") 'helm-M-x)
(global-set-key (kbd "C-x m") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-b") 'helm-mini)
(global-set-key
 (kbd "C-x C-f")
 (lambda () (interactive)
   (if (and (buffer-file-name) (file-remote-p (buffer-file-name)))
       (call-interactively 'find-file)
     (call-interactively 'helm-find-files))))
(global-set-key (kbd "C-o") 'helm-semantic-or-imenu)
(global-set-key (kbd "C-h a") 'helm-apropos)
(global-set-key (kbd "C-M-o") 'helm-swoop)
(global-set-key (kbd "C-c C-M-o") 'helm-multi-swoop)
(helm-descbinds-mode t)

(helm-mode 1)
#+END_SRC

*** Save window geometry
#+BEGIN_SRC emacs-lisp
(defun save-framegeometry ()
  "Gets the current frame's geometry and saves to ~/.emacs.d/framegeometry."
  (let (
        (framegeometry-left (frame-parameter (selected-frame) 'left))
        (framegeometry-top (frame-parameter (selected-frame) 'top))
        (framegeometry-width (frame-parameter (selected-frame) 'width))
        (framegeometry-height (frame-parameter (selected-frame) 'height))
        (framegeometry-file (expand-file-name "~/.emacs.d/framegeometry"))
        )

    (when (not (number-or-marker-p framegeometry-left))
      (setq framegeometry-left 0))
    (when (not (number-or-marker-p framegeometry-top))
      (setq framegeometry-top 0))
    (when (not (number-or-marker-p framegeometry-width))
      (setq framegeometry-width 0))
    (when (not (number-or-marker-p framegeometry-height))
      (setq framegeometry-height 0))

    (with-temp-buffer
      (insert
       ";;; This is the previous emacs frame's geometry.\n"
       ";;; Last generated " (current-time-string) ".\n"
       "(setq initial-frame-alist\n"
       "      '(\n"
       (format "        (top . %d)\n" (max framegeometry-top 0))
       (format "        (left . %d)\n" (max framegeometry-left 0))
       (format "        (width . %d)\n" (max framegeometry-width 0))
       (format "        (height . %d)))\n" (max framegeometry-height 0)))
      (when (file-writable-p framegeometry-file)
        (write-file framegeometry-file))))
  )

(defun load-framegeometry ()
  "Loads ~/.emacs.d/framegeometry which should load the previous frame's geometry."
  (let ((framegeometry-file (expand-file-name "~/.emacs.d/framegeometry")))
    (when (file-readable-p framegeometry-file)
      (load-file framegeometry-file)))
  )

;; Special work to do ONLY when there is a window system being used
(if window-system
    (progn
      (add-hook 'after-init-hook 'load-framegeometry)
      (add-hook 'kill-emacs-hook 'save-framegeometry))
  )
#+END_SRC

*** rich-majority-mode
#+BEGIN_SRC emacs-lisp
(rich-minority-mode 1)
(setq rm-blacklist ".*")
#+END_SRC

*** big-fringe-mode
#+BEGIN_SRC emacs-lisp
(defvar big-fringe-mode nil)
(define-minor-mode big-fringe-mode
  "Minor mode to use big fringe in the current buffer."
  :init-value nil
  :global t
  :variable big-fringe-mode
  :group 'editing-basics
  (if (not big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
           ; + 4 determined empirically
           (* (+ 4 fill-column) (frame-char-width)))
        2))))
#+END_SRC

*** which-key-mode
#+BEGIN_SRC emacs-lisp
(define-globalized-minor-mode global-which-key-mode
  which-key-mode (lambda () (which-key-mode)))
(global-which-key-mode)
#+END_SRC

*** Hide UI elements
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
(tool-bar-mode -1)
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(unless (and (eq system-type 'darwin) (display-graphic-p)) (menu-bar-mode -1))
#+END_SRC

*** Copy paste
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setq x-select-enable-clipboard t
      x-select-enable-primary t
      save-interprogram-paste-before-kill t
      mouse-yank-at-point t)
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)

(blink-cursor-mode 0)

(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

#+END_SRC

*** Mac OS X
#+BEGIN_SRC emacs-lisp
(setq ns-command-modifier (quote control))
(global-set-key (kbd "<f9>") 'toggle-frame-fullscreen)
#+END_SRC

** Editing

*** M-{n,p} for paragraph movement
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)
#+END_SRC

*** jcs-comment-box
#+BEGIN_SRC emacs-lisp
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (save-restriction
    (narrow-to-region b e)
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b (point-max) 1)
    (goto-char (point-max))))
#+END_SRC

*** Newline indents
#+BEGIN_SRC emacs-lisp
(clean-aindent-mode t)
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Undoing, undo tree
#+BEGIN_SRC emacs-lisp
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(global-undo-tree-mode 1)
(global-set-key (kbd "C-z") 'undo)
(global-set-key (kbd "C-x C-u") 'undo-tree-visualize)
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
;; flyspell needs location of aspell on Mac
(setq ispell-list-command "--list")
(when (eq system-type 'darwin)
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin"))))
(add-hook 'org-journal-mode-hook 'flyspell-mode)
; (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

*** comment-or-uncomment-line-or-region
#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
(global-set-key (kbd "M-[ q") 'comment-or-uncomment-line-or-region)
; (global-set-key (kbd "C-;") 'comment-or-uncomment-line-or-region)
(global-set-key [remap comment-dwim] 'comment-or-uncomment-line-or-region)
#+END_SRC

*** exchange-point-and-mark-no-activate
#+BEGIN_SRC emacs-lisp
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(global-set-key (kbd "C-x C-x") 'exchange-point-and-mark-no-activate)
#+END_SRC

*** Better C-w
#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

*** Better C-{a,e}
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-a") 'mwim-beginning-of-code-or-line)
(global-set-key (kbd "C-e") 'mwim-end-of-code-or-line)
(global-set-key (kbd "<home>") 'mwim-beginning-of-code-or-line)
(global-set-key (kbd "<end>") 'mwim-end-of-code-or-line)
(setq mwim-beginning-of-line-function 'beginning-of-line)
(setq mwim-end-of-line-function 'end-of-line)
#+END_SRC

*** can keep C-u C-SPC C-SPC C-SPC
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** highlight-symbol-mode
#+BEGIN_SRC emacs-lisp
;; I have a feeling this is laggy, and its more or less replaced by occur at point
;; (define-globalized-minor-mode global-highlight-symbol-mode
;;   highlight-symbol-mode (lambda () (progn (highlight-symbol-mode) (highlight-symbol-nav-mode))))
;; (setq highlight-symbol-idle-delay 0.5)
;; (global-highlight-symbol-mode)
#+END_SRC

*** Truncate lines
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c s")   'toggle-truncate-lines)
(global-set-key (kbd "C-c C-s") 'toggle-truncate-lines)
(set-default 'truncate-lines t)
#+END_SRC

*** zap-up-to-char
#+BEGIN_SRC emacs-lisp
(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.
  
  \(fn arg char)"
  'interactive)
(global-set-key (kbd "M-Z") 'zap-up-to-char)
#+END_SRC

*** ace-isearch-mode
#+BEGIN_SRC emacs-lisp
(setq ace-isearch-jump-delay 1)
(global-ace-isearch-mode t)
#+END_SRC

*** org
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-M-u") 'org-up-element)
(setq org-startup-folded nil)
#+END_SRC

*** org-journal
#+BEGIN_SRC emacs-lisp
(setq org-journal-date-format "%A, %d/%m/%Y")
(setq sorg-journal-file-format "%Y%m%d.txt")
(setq org-journal-dir "~/Google Drive/journal/")
(setq org-journal-hide-entries-p nil)
(setq org-journal-find-file 'find-file)
(add-hook 'org-journal-mode-hook 'auto-fill-mode)
; whitespace-mode is fairly useless in org-journal. remap its key to set the
; frame with to the fillcolumn + empirical value
(add-hook 'org-journal-mode-hook
          (lambda ()
            (define-key org-journal-mode-map (kbd "C-c w")
              (lambda () (interactive)
                (set-frame-width (selected-frame) (+ 1 fill-column))))))
(defun set-frame-width-interactive (arg)
  (interactive "nFrame width: ")
  (set-frame-width (selected-frame) arg))
#+END_SRC

*** Copy current workspace prefix
#+BEGIN_SRC emacs-lisp
(defun copy-current-workspace-prefix ()
  (interactive)
  (kill-new (replace-regexp-in-string "^\\(.+\\)/src.*$" "\\1" buffer-file-name)))
#+END_SRC

*** electric-pair-mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode)
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
(setq-default fill-column 80)
(delete-selection-mode 1)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Programming

*** Languages

**** Python
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'anaconda-mode)
; because python-mode overwrites it
(add-hook 'python-mode-hook
 (lambda () (add-to-list 'completion-at-point-functions 'company-complete)))
;; (eval-after-load 'company
;;   '(add-to-list 'company-backends '(company-dabbrev-code company-anaconda)))

;; using flymake since it works with pylint < 1.0.0
;; (require 'flymake)

;; (defun flymake-pylint-init ()
;;   (let* ((temp-file (flymake-init-create-temp-buffer-copy
;;                      'flymake-create-temp-inplace))
;;          (local-file (file-relative-name
;;                       temp-file
;;                       (file-name-directory buffer-file-name))))
;;     (list "epylint" (list local-file))))
;; (add-to-list 'flymake-allowed-file-name-masks
;;              '("\\.py\\'" flymake-pylint-init))
;; (add-hook 'python-mode-hook
;;           (lambda()
;;             (unless (file-remote-p (buffer-file-name))
;;               (define-prefix-command 'fake-flycheck-map)
;;               (local-set-key (kbd "C-c !") 'fake-flycheck-map)
;;               (local-set-key (kbd "C-c ! h") 'flymake-popup-current-error-menu)
;;               (local-set-key (kbd "C-c ! n") 'flymake-goto-next-error)
;;               (local-set-key (kbd "C-c ! p") 'flymake-goto-prev-error)
;;               (flymake-mode))
;; ))
#+END_SRC

**** Perl
#+BEGIN_SRC emacs-lisp
(add-hook 'perl-mode-hook (lambda () (progn
                                       (define-key perl-mode-map (kbd "C-c C-d") 'cperl-perldoc)
                                       )))
#+END_SRC

**** ASM mode
#+BEGIN_SRC emacs-lisp
(eval-after-load 'asm-mode
  '(define-key asm-mode-map [(tab)] 'asm-indent-line))
#+END_SRC

**** Makefile
#+BEGIN_SRC emacs-lisp
(add-hook 'makefile-mode-hook (lambda () (setq indent-tabs-mode t)))

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.vt\\'" . verilog-mode))
#+END_SRC

**** C-like
***** Semantic
#+BEGIN_SRC emacs-lisp
;; (semantic-mode)
;; (global-semantic-stickyfunc-mode)
#+END_SRC

***** No namespace intent
#+BEGIN_SRC emacs-lisp
(defun no-ns-indent ()
   (c-set-offset 'innamespace [0]))
(add-hook 'c++-mode-hook 'no-ns-indent)
#+END_SRC

***** Company
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook (lambda () (add-to-list 'company-backends '(company-capf company-dabbrev))))
#+END_SRC

**** Diffing
#+BEGIN_SRC emacs-lisp
(add-hook 'diff-mode-hook (lambda () (m-buffer-binds (current-local-map))))
(setq diff-switches "-u")
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(eval-after-load 'ediff
  '(progn
     (set-face-foreground 'ediff-fine-diff-A "white")
     (set-face-foreground 'ediff-fine-diff-B "white")
     ))
#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp
(add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
(add-hook 'rust-mode-hook 'flycheck-mode)
(add-hook 'perl-mode-hook 'flycheck-mode)
#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
(global-company-mode 1)
(setq company-require-match nil)
(setq company-idle-delay nil)
(setq company-dabbrev-downcase nil)

(setq tab-always-indent 'complete)
;; (add-to-list 'company-backends 'company-dabbrev)
(setq company-dabbrev-code-other-buffers 'all)

(defvar completion-at-point-functions-saved nil)

(defun company-indent-for-tab-command (&optional arg)
  (interactive "P")
  (let ((completion-at-point-functions-saved completion-at-point-functions)
        (completion-at-point-functions '(company-complete-common-wrapper)))
    (indent-for-tab-command arg)))

(defun company-complete-common-wrapper ()
  (let ((completion-at-point-functions completion-at-point-functions-saved))
    (company-complete-common)))

(define-key company-mode-map [remap indent-for-tab-command]
  'company-indent-for-tab-command)
(define-key company-mode-map [remap c-indent-line-or-region]
  'company-indent-for-tab-command)
#+END_SRC

*** Projectile RIP
#+BEGIN_SRC emacs-lisp
;; (add-hook 'projectile-mode-hook
;;           (lambda ()
;;             (define-key projectile-mode-map (kbd "C-c C-p") 'projectile-command-map)
;;             (define-key projectile-mode-map (kbd "C-x f") 'projectile-find-file)))
;; (setq projectile-mode-line
;;    (quote
;;     (:eval
;;      (if
;;          (file-remote-p default-directory)
;;          ""
;;        (format " \@%s"
;;                (projectile-project-name))))))
;; (setq projectile-completion-system 'helm)
;; (projectile-global-mode)
;; (helm-projectile-on)
#+END_SRC

*** hl-line-mode
#+BEGIN_SRC emacs-lisp
(if window-system
    (progn
      (add-hook 'prog-mode-hook 'hl-line-mode)
  ))
#+END_SRC

*** which-function-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'which-function-mode)
#+END_SRC

*** compiling
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (global-set-key (kbd "<f7>")   'compile)))
(add-hook 'prog-mode-hook (lambda () (global-set-key (kbd "<f8>") 'recompile)))
(setq compilation-message-face 'default)
#+END_SRC

*** Line numbers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'nlinum-mode)
#+END_SRC

*** Show parens 
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (progn
                                       (show-paren-mode 1)
                                       (setq show-paren-delay 0))))
#+END_SRC

*** Indent
#+BEGIN_SRC emacs-lisp
;; guess offset don't need the global modeline
(dtrt-indent-mode 1)
(add-hook 'prog-mode-hook (lambda() (delete 'dtrt-indent-mode-line-info global-mode-string)))

(setq-default indent-tabs-mode nil)
(setq c-default-style "linux")
(if (locate-library "arista") (setq c-basic-offset 3) (setq c-basic-offset 4))
;; (add-to-list 'c-offsets-alist '(arglist-close . c-linup-close-paren))
#+END_SRC

*** whitespace-mode
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC

*** yafolding-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'yafolding-mode)
#+END_SRC

*** Term
#+BEGIN_SRC emacs-lisp
(defun term-into-dir (arg)
  (interactive "P")
  (let ((arg2 t))
    (when (consp arg) (setq arg2 nil))
    (if (file-remote-p default-directory)
        (let ((dissected (tramp-dissect-file-name default-directory)))
          (let ((host (tramp-file-name-host dissected))
                ;; (user (tramp-file-name-user dissected))
                (dir  (tramp-file-name-localname dissected)))
            (term-run-shell-command (concat "ssh -t " host " 'cd " dir " && exec bash -l'") arg2)
            ))
      (term-run-shell-command (concat "cd " default-directory " && exec bash -l") arg2)
      )))
(global-set-key (kbd "<f6>") 'term-into-dir)
(setq term-suppress-hard-newline t)
(setq term-prompt-regexp "^.*[%$] ")
(add-hook 'term-mode-hook
          (lambda ()
            (term-set-escape-char ?\C-x)
            (setq term-buffer-maximum-size 20000)
            (toggle-truncate-lines nil) 
            ))
(eval-after-load 'term
  '(progn
     (define-key term-mode-map (kbd "C-x C-k") 'term-char-mode)
     (defun term-send-backwards-delete-word () (interactive) (term-send-raw-string "\C-w"))
     (define-key term-raw-map (kbd "<C-backspace>") 'term-send-backwards-delete-word)
     (define-key term-raw-map (kbd "<M-backspace>") 'term-send-backwards-delete-word)
     (define-key term-mode-map (kbd "TAB") (lambda () (interactive) (term-send-raw-string "\t")))
     (define-key term-mode-map (kbd "C-x C-j") (lambda nil (interactive)))
     (setq comint-move-point-for-output nil)
     (setq comint-scroll-show-maximum-output nil)
     (m-buffer-binds term-raw-map)
     ))
#+END_SRC

*** subword-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

*** Springboard
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'springboard)
#+END_SRC

** Meta/misc

*** When editing this file, C-c m to switch between org-mode and elisp. Yup...
#+BEGIN_SRC emacs-lisp
(setq switch-org-and-elisp-map (make-sparse-keymap))

(define-minor-mode switch-org-and-elisp-mode
  ""
  nil
  nil
  switch-org-and-elisp-map)
(define-key switch-org-and-elisp-map (kbd "C-c m")
  (lambda () (interactive)
    (if (string= 'emacs-lisp-mode major-mode)
        (progn (org-mode) (switch-org-and-elisp-mode t))
      (progn (emacs-lisp-mode) (switch-org-and-elisp-mode t)))
    ))

;; Local Variables:
;; eval: (switch-org-and-elisp-mode 1)
;; End:
#+END_SRC
*** TRAMP
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
(setq tramp-default-method 'ssh)
(setq tramp-use-ssh-controlmaster-options nil)
(global-set-key (kbd "<f5>")
                ;; (lambda () (interactive)
                ;;   (tramp-cleanup-all-connections)
                ;;   (let ((default-directory ""))
                ;;     (shell-command "rm ~/.ssh/controlmasters/*")))
                'tramp-cleanup-all-connections
                )
(setq auto-revert-remote-files t)
(setq vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))
#+END_SRC

** Emacs server
#+BEGIN_SRC emacs-lisp
;; (when (getenv "EMACS_SESSION_DIR") (setq server-socket-dir (getenv "EMACS_SESSION_DIR")))
(server-start)
#+END_SRC

