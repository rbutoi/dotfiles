* Emacs settings

** Loading stuff/setup

#+BEGIN_SRC emacs-lisp
(package-initialize)

(if (locate-library "cask") (load-library "cask")
  (require 'cask "~/.cask/cask.el"))
(cask-initialize)
(require 'pallet)
(pallet-mode t)

(require 'cl)

(add-to-list 'load-path "~/.emacs.d/lisp/")

(setq custom-file "~/.emacs.d/custom.el")
(when (file-readable-p custom-file) (load custom-file))
(setq specific-file "~/.emacs.d/specific.el")
(when (file-readable-p specific-file) (load specific-file))
#+END_SRC

** UI

*** Theme
#+BEGIN_SRC emacs-lisp
;; toggle dark/light
(when window-system
  (defun toggle-solarized-twilight-off ()
    (interactive)
    (cond ((string= next-bg 'dark)
           (progn
             (disable-theme 'twilight-bright)
             (load-theme 'solarized-dark)

             (setq next-bg 'light)
             ))
          ((string= next-bg 'light)
           (progn
             (disable-theme 'solarized-dark)
             (load-theme 'twilight-bright)

             (setq next-bg 'off)
             ))
          ((string= next-bg 'off)
           (progn
             (disable-theme 'twilight-bright)
             (setq next-bg 'dark)
             ))))

  (load-theme 'solarized-dark)
  (setq next-bg 'light)
  
  (cond
   ((find-font (font-spec :name "Ubuntu Mono"))
    (set-frame-font "Ubuntu Mono-12"))
   ((find-font (font-spec :name "DejaVu Sans Mono"))
    (set-frame-font "DejaVu Sans Mono-10"))
   ((find-font (font-spec :name "Consolas"))
    (set-frame-font "Consolas-11"))
   )

  (global-set-key (kbd "C-x 7") 'toggle-solarized-twilight-off)
  (global-set-key (kbd "C-x C-7") 'toggle-solarized-twilight-off)
  )

;; make window divider prettier
(let ((display-table (or standard-display-table (make-display-table))))
  (set-display-table-slot display-table 'vertical-border (make-glyph-code ?â”‚))
  (setq standard-display-table display-table))

;; a bit more contrast to keep track of curent window
(set-face-attribute  'mode-line
                     nil
                     :box '(:line-width 3 :style released-button))
(set-face-attribute  'mode-line-inactive
                     nil
                     :box nil
                     )
(eval-after-load 'hl-line
  (lambda () (set-face-attribute 'hl-line nil
                                 ;; :underline t
                                 )))
(eval-after-load 'which-func
  (lambda () (set-face-attribute 'which-func nil :foreground "dark cyan")))

(when (string-match-p "eecg" system-name) (normal-erase-is-backspace-mode 0))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/\\1" t)))
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-auto-revert-mode 1)
(setq-default save-place t)
(setq save-place-file "~/.emacs.d/saved-places")
(setq recentf-max-saved-items 1000)
(setq recentf-save-file "~/.emacs.d/recentf")
#+END_SRC

*** Buffers and windows
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?o))
(global-set-key (kbd "C-x o") 'ace-window)
(global-set-key (kbd "C-x C-o") 'ace-window)
(defun m-buffer-binds (map)
  (define-key map (kbd "M-o") 'other-window)
  (define-key map (kbd "M-i") (lambda() (interactive) (other-window -1)))
  (define-key map (kbd "M-l")
    (lambda() (interactive) (select-window (get-mru-window t t t))))
  (define-key map (kbd "C-k") 'kill-this-buffer) ; defies name but whatevs

  (define-key map (kbd "M-0") 'delete-window)
  (define-key map (kbd "M-1") 'delete-other-windows)
  (define-key map (kbd "M-2") 'split-window-below)
  (define-key map (kbd "M-3") 'split-window-right)
  (define-key map (kbd "M-=") 'balance-windows))
(m-buffer-binds (current-global-map))

(global-set-key (kbd "C-x C-z") 'zoom-window-zoom)

(setq split-height-threshold nil
      split-width-threshold nil) ; let me split

(global-set-key (kbd "<C-S-up>")     'buf-move-up)
(global-set-key (kbd "<C-S-down>")   'buf-move-down)
(global-set-key (kbd "<C-S-left>")   'buf-move-left)
(global-set-key (kbd "<C-S-right>")  'buf-move-right)

(setq golden-ratio-adjust-factor 0.65)
;; (global-set-key (kbd "C-x C-g") 'golden-ratio)
;; (global-set-key (kbd "C-x C-G") 'golden-ratio-mode)
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp
(require 'helm-config)
(helm-mode 1)
(helm-descbinds-mode t)

;; (setq helm-buffer-max-length 30)
(setq helm-buffer-skip-remote-checking t)
(setq helm-split-window-default-side 'same)

(let ((ack "ag"))
  (when (file-exists-p "~/bin/ack") (setq ack "~/bin/ack"))
  (setq helm-grep-default-command
        (concat ack " -Hn --color --smart-case --no-group %p %f")
        helm-grep-default-recurse-command
        (concat ack " -H  --color --smart-case --no-group %p %f"))
  (setq helm-ag-base-command (concat ack " --nocolor --nogroup --smart-case")))
(setq helm-ag-insert-at-point 'word)
(global-set-key (kbd "C-M-s")
                (lambda (&optional arg) (interactive "P")
                  (if (file-remote-p default-directory)
                      (setq helm-ag-base-command (concat "~/bin/ack --nocolor --nogroup --smart-case"))
                    (setq helm-ag-base-command (concat "ag --nocolor --nogroup --smart-case"))
                    )
                  (if arg
                      (helm-do-ag)
                    (helm-do-ag default-directory))
                  ))
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(define-key helm-map (kbd "C-k") 'helm-execute-persistent-action)
(global-unset-key (kbd "C-x c"))
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x m") 'helm-M-x)
(global-set-key (kbd "C-x C-m") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-b") 'mode-line-other-buffer)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-x f") 'find-file)
(global-set-key (kbd "C-o") 'helm-semantic-or-imenu)
(global-set-key (kbd "C-h a") 'helm-apropos)
(global-set-key (kbd "C-M-o") 'helm-swoop)
(global-set-key (kbd "C-c C-M-o") 'helm-multi-swoop)
#+END_SRC

*** Save window geometry
#+BEGIN_SRC emacs-lisp
(defun save-framegeometry ()
  "Gets the current frame's geometry and saves to ~/.emacs.d/framegeometry."
  (let (
        (framegeometry-left (frame-parameter (selected-frame) 'left))
        (framegeometry-top (frame-parameter (selected-frame) 'top))
        (framegeometry-width (frame-parameter (selected-frame) 'width))
        (framegeometry-height (frame-parameter (selected-frame) 'height))
        (framegeometry-file (expand-file-name "~/.emacs.d/framegeometry"))
        )

    (when (not (number-or-marker-p framegeometry-left))
      (setq framegeometry-left 0))
    (when (not (number-or-marker-p framegeometry-top))
      (setq framegeometry-top 0))
    (when (not (number-or-marker-p framegeometry-width))
      (setq framegeometry-width 0))
    (when (not (number-or-marker-p framegeometry-height))
      (setq framegeometry-height 0))

    (with-temp-buffer
      (insert
       ";;; This is the previous emacs frame's geometry.\n"
       ";;; Last generated " (current-time-string) ".\n"
       "(setq initial-frame-alist\n"
       "      '(\n"
       (format "        (top . %d)\n" (max framegeometry-top 0))
       (format "        (left . %d)\n" (max framegeometry-left 0))
       (format "        (width . %d)\n" (max framegeometry-width 0))
       (format "        (height . %d)))\n" (max framegeometry-height 0)))
      (when (file-writable-p framegeometry-file)
        (write-file framegeometry-file))))
  )

(defun load-framegeometry ()
  "Loads ~/.emacs.d/framegeometry which should load the previous frame's geometry."
  (let ((framegeometry-file (expand-file-name "~/.emacs.d/framegeometry")))
    (when (file-readable-p framegeometry-file)
      (load-file framegeometry-file)))
  )

;; Special work to do ONLY when there is a window system being used
(when window-system
  (add-hook 'after-init-hook 'load-framegeometry)
  (add-hook 'kill-emacs-hook 'save-framegeometry))
#+END_SRC

*** rich-majority-mode
#+BEGIN_SRC emacs-lisp
(rich-minority-mode 1)
(setq rm-blacklist ".*")
#+END_SRC

*** big-fringe-mode
#+BEGIN_SRC emacs-lisp
(defvar big-fringe-mode nil)
(define-minor-mode big-fringe-mode
  "Minor mode to use big fringe in the current buffer."
  :init-value nil
  :global t
  :variable big-fringe-mode
  :group 'editing-basics
  (if (not big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
                                        ; + 4 determined empirically
           (* (+ 4 fill-column) (frame-char-width)))
        2))))
#+END_SRC

*** which-key-mode
#+BEGIN_SRC emacs-lisp
(define-globalized-minor-mode global-which-key-mode
  which-key-mode (lambda () (which-key-mode)))
(global-which-key-mode)
#+END_SRC

*** Hide UI elements
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
(tool-bar-mode -1)
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(unless (and (eq system-type 'darwin) (display-graphic-p)) (menu-bar-mode -1))
#+END_SRC

*** Copy paste
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setq x-select-enable-clipboard t
      x-select-enable-primary t
      save-interprogram-paste-before-kill t
      mouse-yank-at-point t)
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)

(blink-cursor-mode 0)

(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

#+END_SRC

*** Mac OS X
#+BEGIN_SRC emacs-lisp
(setq ns-command-modifier (quote control))
(global-set-key (kbd "<f9>") 'toggle-frame-fullscreen)
#+END_SRC

** Editing

*** M-{n,p} for paragraph movement
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)
#+END_SRC

*** jcs-comment-box
#+BEGIN_SRC emacs-lisp
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (save-restriction
    (narrow-to-region b e)
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b (point-max) 1)
    (goto-char (point-max))))
#+END_SRC

*** Newline indents
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Undoing, undo tree
#+BEGIN_SRC emacs-lisp
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(global-undo-tree-mode 1)
(global-set-key (kbd "C-z") 'undo)
(global-set-key (kbd "C-x C-u") 'undo-tree-visualize)
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
;; (setq ispell-list-command "--list")
(add-hook 'org-journal-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

*** comment-or-uncomment-line-or-region
#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (progn
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (forward-line))
    ))
(global-set-key (kbd "M-[ q") 'comment-or-uncomment-line-or-region)
;; (global-set-key (kbd "C-;") 'comment-or-uncomment-line-or-region)
(global-set-key [remap comment-dwim] 'comment-or-uncomment-line-or-region)
#+END_SRC

*** exchange-point-and-mark-no-activate
#+BEGIN_SRC emacs-lisp
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(global-set-key (kbd "C-x C-x") 'exchange-point-and-mark-no-activate)
#+END_SRC

*** Better C-w
#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-ring-save (before slick-cut activate compile)
  "When called interactively with no active region, save a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

*** Better C-{a,e}
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-a") 'mwim-beginning-of-code-or-line)
(global-set-key (kbd "C-e") 'mwim-end-of-code-or-line)
(global-set-key (kbd "<home>") 'mwim-beginning-of-code-or-line)
(global-set-key (kbd "<end>") 'mwim-end-of-code-or-line)
(setq mwim-beginning-of-line-function 'beginning-of-line)
(setq mwim-end-of-line-function 'end-of-line)
#+END_SRC

*** can keep C-u C-SPC C-SPC C-SPC
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** Truncate lines
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c s")   'toggle-truncate-lines)
(global-set-key (kbd "C-c C-s") 'toggle-truncate-lines)
(set-default 'truncate-lines t)
#+END_SRC

*** zap-up-to-char
#+BEGIN_SRC emacs-lisp
(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.

  \(fn arg char)"
  'interactive)
(global-set-key (kbd "M-Z") 'zap-up-to-char)
#+END_SRC

*** just-one-space
#+BEGIN_SRC emacs-lisp

;; to get around xmonad
(global-set-key (kbd "C-M-SPC") 'just-one-space)
#+END_SRC

*** org
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-M-u") 'org-up-element)
(add-hook 'org-mode-hook (lambda () (m-buffer-binds (current-local-map))))

(setq org-startup-folded nil)
#+END_SRC

*** org-journal
#+BEGIN_SRC emacs-lisp
(setq org-journal-date-format "%A, %d/%m/%Y")
(setq sorg-journal-file-format "%Y%m%d.txt")
(setq org-journal-dir "~/Documents/google-drive/journal/")
(setq org-journal-hide-entries-p nil)
(setq org-journal-find-file 'find-file)
(add-hook 'org-journal-mode-hook 'auto-fill-mode)
                                        ; whitespace-mode is fairly useless in org-journal. remap its key to set the
                                        ; frame with to the fillcolumn + empirical value
(add-hook 'org-journal-mode-hook
          (lambda ()
            (define-key org-journal-mode-map (kbd "C-c w")
              (lambda () (interactive)
                (set-frame-width (selected-frame) (+ 1 fill-column))))
            (define-key org-journal-mode-map (kbd "<f7>")
              (lambda () (interactive)
                (async-shell-command "yes Y | drive push")))
            ))
(defun set-frame-width-interactive (arg)
  (interactive "nFrame width: ")
  (set-frame-width (selected-frame) arg))
#+END_SRC

*** Copy current path name
#+BEGIN_SRC emacs-lisp
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

*** electric-pair-mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode)
#+END_SRC

*** visual-line-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC

*** ztree
#+BEGIN_SRC emacs-lisp
(setq ztree-draw-unicode-lines t)
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
(setq-default fill-column 80)
(delete-selection-mode 1)
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Programming

*** Languages

**** Perl
#+BEGIN_SRC emacs-lisp
(add-hook 'perl-mode-hook (lambda () (progn
                                       (define-key perl-mode-map (kbd "C-c C-d") 'cperl-perldoc)
                                       )))
#+END_SRC

**** ASM mode
#+BEGIN_SRC emacs-lisp
(eval-after-load 'asm-mode
  '(define-key asm-mode-map [(tab)] 'asm-indent-line))
#+END_SRC

**** Makefile
#+BEGIN_SRC emacs-lisp
(add-hook 'makefile-mode-hook (lambda () (setq indent-tabs-mode t)))

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.vt\\'" . verilog-mode))
#+END_SRC

**** C-like
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook 'electric-pair-local-mode)
#+END_SRC

***** Irony
#+BEGIN_SRC emacs-lisp
(require 'rtags)
(require 'company)
(require 'irony)
(require 'company-irony)

(add-hook 'c++-mode-hook 'irony-mode)
(add-hook 'c-mode-hook 'irony-mode)
(add-hook 'objc-mode-hook 'irony-mode)

(add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
(setq irony-cdb-search-directory-list '("." "build" "build-Debug" "build-Release"))
#+END_SRC

***** Company
#+BEGIN_SRC emacs-lisp
(defun setup-c/c++-company-backends ()
  (setq-local company-backends '(company-irony company-irony-c-headers)))
(add-hook 'c++-mode-hook 'setup-c/c++-company-backends)
(add-hook 'c-mode-hook 'setup-c/c++-company-backends)
(add-hook 'objc-mode-hook 'setup-c/c++-company-backends)

#+END_SRC

***** RTags
#+BEGIN_SRC emacs-lisp
(rtags-enable-standard-keybindings c-mode-base-map "C-c C-r ")
(define-key c-mode-base-map (kbd "M-.") 'rtags-find-symbol-at-point)
(define-key c-mode-base-map (kbd "M-,") 'rtags-find-references-at-point)
(define-key c-mode-base-map (kbd "C-o") 'rtags-imenu) ; helm-sem
(define-key c-mode-base-map (kbd "C-c C-r f") 'rtags-next-match)
(define-key c-mode-base-map (kbd "C-c C-r b") 'rtags-previous-match)
#+END_SRC

***** No namespace intent
#+BEGIN_SRC emacs-lisp
(defun no-ns-indent ()
   (c-set-offset 'innamespace [0]))
(add-hook 'c++-mode-hook 'no-ns-indent)
#+END_SRC

**** Diffing
#+BEGIN_SRC emacs-lisp
(add-hook 'diff-mode-hook (lambda () (m-buffer-binds (current-local-map))))
(setq diff-switches "-u")
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(eval-after-load 'ediff
  '(progn
     (set-face-foreground 'ediff-fine-diff-A "white")
     (set-face-foreground 'ediff-fine-diff-B "white")
     ))
#+END_SRC

**** LaTeX
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (setq TeX-auto-untabify t     ;; remove all tabs before saving
                  ;; TeX-view-program-list '(("LLPP" "killall -SIGHUP llpp || llpp %o"))
                  TeX-view-program-list '(("Xreader" "xreader %o"))
                  TeX-view-program-selection '((output-pdf "Xreader")))
            (auto-fill-mode)
            (setq TeX-command-force "LaTeX")
            ))
#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp
(add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
(add-hook 'rust-mode-hook 'flycheck-mode)
(add-hook 'perl-mode-hook 'flycheck-mode)
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
(add-hook 'c-mode-hook 'flycheck-mode)
(add-hook 'c++-mode-hook 'flycheck-mode)

(setq flycheck-display-errors-delay 0)
#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
(global-company-mode)
(define-key company-mode-map [remap indent-for-tab-command]
  'company-indent-or-complete-common)
(define-key company-mode-map [remap c-indent-line-or-region]
  'company-indent-or-complete-common)
(setq
 company-idle-delay nil
 tab-always-indent 'complete
 company-dabbrev-downcase nil)
;; Put -capf with dabbrev
(setq company-backends (delete 'company-capf company-backends))
(setq company-backends (delete 'company-dabbrev company-backends))
(add-to-list 'company-backends '(company-capf :with company-dabbrev))

;; Messy, but it works
(global-set-key (kbd "<C-tab>") 'hippie-expand)
#+END_SRC

*** projectile
#+BEGIN_SRC emacs-lisp
(projectile-mode 1)
(add-to-list 'projectile-globally-ignored-modes 'term-mode)
(helm-projectile-on)

(add-hook
 'c-mode-common-hook
 (lambda ()
   (local-set-key (kbd "C-c C-o")
                  (lambda () (interactive)
                                    (if (projectile-project-p)
                                        (projectile-find-other-file) (ff-find-other-file))))))
#+END_SRC

*** yasnippets
#+BEGIN_SRC emacs-lisp
(yas-global-mode 1)
#+END_SRC

*** hl-line-mode
#+BEGIN_SRC emacs-lisp
(when window-system
  (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

*** which-function-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'which-function-mode)
#+END_SRC

*** compiling
#+BEGIN_SRC emacs-lisp
(defun close-compile-window-if-successful (buffer string)
  " close a compilation window if succeeded without warnings "
  (if (and
       (string-match "compilation" (buffer-name buffer))
       (string-match "finished" string)
       (not
        (with-current-buffer buffer
          (search-forward "warning" nil t))))
      (run-with-timer 1 nil
                      (lambda (window) (quit-window nil window))
                      (get-buffer-window buffer))))
(add-hook 'compilation-finish-functions 'close-compile-window-if-successful)

(add-hook 'prog-mode-hook
          (lambda () (global-set-key (kbd "<f7>")
                                     (lambda () (interactive)
                                       (when (locate-dominating-file default-directory "Makefile")
                                          (with-temp-buffer (cd (locate-dominating-file default-directory "Makefile")) (call-interactively 'compile)))))))
(add-hook 'prog-mode-hook (lambda () (global-set-key (kbd "<f8>") 'recompile)))
(setq compilation-message-face 'default)
#+END_SRC

*** Line numbers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'nlinum-mode)
#+END_SRC

*** Parens
#+BEGIN_SRC emacs-lisp
(require 'smartparens-config)
(smartparens-global-mode 1)
(define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
(define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)

(define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)
(define-key smartparens-mode-map (kbd "C-M-a") 'sp-backward-down-sexp)
(define-key smartparens-mode-map (kbd "C-S-d") 'sp-beginning-of-sexp)
(define-key smartparens-mode-map (kbd "C-S-a") 'sp-end-of-sexp)

(define-key smartparens-mode-map (kbd "C-M-e") 'sp-up-sexp)
(define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
(define-key smartparens-mode-map (kbd "C-M-t") 'sp-transpose-sexp)

(define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
(define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

(define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)
(define-key smartparens-mode-map (kbd "C-M-w") 'sp-copy-sexp)

;; (define-key smartparens-mode-map (kbd "M-<delete>") 'sp-unwrap-sexp)
;; (define-key smartparens-mode-map (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

(define-key smartparens-mode-map (kbd "C-<right>") 'sp-forward-slurp-sexp)
(define-key smartparens-mode-map (kbd "C-<left>") 'sp-forward-barf-sexp)
(define-key smartparens-mode-map (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
(define-key smartparens-mode-map (kbd "C-M-<right>") 'sp-backward-barf-sexp)

(define-key smartparens-mode-map (kbd "M-D") 'sp-splice-sexp)
(define-key smartparens-mode-map (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
(define-key smartparens-mode-map (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
(define-key smartparens-mode-map (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

(define-key smartparens-mode-map (kbd "C-]") 'sp-select-next-thing-exchange)
(define-key smartparens-mode-map (kbd "C-<left_bracket>") 'sp-select-previous-thing)
(define-key smartparens-mode-map (kbd "C-M-]") 'sp-select-next-thing)

(define-key smartparens-mode-map (kbd "M-F") 'sp-forward-symbol)
(define-key smartparens-mode-map (kbd "M-B") 'sp-backward-symbol)

(define-key smartparens-mode-map (kbd "C-c f") (lambda () (interactive) (sp-beginning-of-sexp 2)))
(define-key smartparens-mode-map (kbd "C-c b") (lambda () (interactive) (sp-beginning-of-sexp -2)))

(add-hook 'prog-mode-hook
          (lambda () (show-paren-mode 1)
            (setq show-paren-delay 0)))
#+END_SRC

*** Indent
#+BEGIN_SRC emacs-lisp
;; guess offset don't need the global modeline
(dtrt-indent-mode 1)
(add-hook 'prog-mode-hook (lambda() (delete 'dtrt-indent-mode-line-info global-mode-string)))
(setq-default tab-width 4)

(setq-default indent-tabs-mode nil)
(setq c-default-style "k&r"
      c-basic-offset 4)
#+END_SRC

*** whitespace-mode
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'whitespace-mode)
(global-set-key (kbd "C-c C-w") 'whitespace-mode)
#+END_SRC

*** yafolding-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'yafolding-mode)
#+END_SRC

*** Term
#+BEGIN_SRC emacs-lisp

(defun term-into-dir-internal (create)
  (let ((cmd ""))
    (when (file-remote-p default-directory)
        (let ((dissected (tramp-dissect-file-name default-directory)))
          (let ((host (tramp-file-name-host dissected))
                (user (tramp-file-name-user dissected))
                (dir  (tramp-file-name-localname dissected)))
            (setq ssh-cd-command (concat "exec ssh -t " user "@" host " 'cd " dir " && exec bash -l'"))
            )))
    (if create
        (sane-term-create)
      (sane-term))
    (when (file-remote-p default-directory)
      (run-with-timer 0.125 nil (lambda ()
                              (term-line-mode)
                              (goto-char (point-max))
                              (insert ssh-cd-command)
                              (term-send-input)
                              (term-char-mode))))))
(defun term-into-dir (arg)
  (interactive "P")
  (term-into-dir-internal nil))

(defun term-into-dir-create (arg)
  (interactive "P")
  (term-into-dir-internal t))

(global-set-key (kbd "<f6>") 'term-into-dir)
(global-set-key (kbd "S-<f6>") 'term-into-dir-create)

(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))

(global-unset-key (kbd "M-!"))
(global-set-key (kbd "C-!") 'shell-command)
(setq term-suppress-hard-newline t)
(setq term-prompt-regexp "^.*[%$] ")
(add-hook 'term-mode-hook
          (lambda ()
            (term-set-escape-char ?\C-x)
            (setq term-buffer-maximum-size 20000)
            (toggle-truncate-lines nil)
            ))
(eval-after-load 'term
  '(progn
     (define-key term-mode-map (kbd "C-x C-k") 'term-char-mode)
     (defun term-send-backwards-delete-word () (interactive) (term-send-raw-string "\C-w"))
     (define-key term-raw-map (kbd "<C-backspace>") 'term-send-backwards-delete-word)
     (define-key term-raw-map (kbd "<M-backspace>") 'term-send-backwards-delete-word)
     (define-key term-mode-map (kbd "TAB") (lambda () (interactive) (term-send-raw-string "\t")))
     (define-key term-mode-map (kbd "C-x C-j") (lambda nil (interactive)))
     (setq comint-move-point-for-output nil)
     (setq comint-scroll-show-maximum-output nil)
     (m-buffer-binds term-raw-map)
     ))
#+END_SRC

*** subword-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

*** magit
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x g") 'magit-status)
#+END_SRC

** Meta/misc

*** When editing this file, C-c m to switch between org-mode and elisp. Yup...
#+BEGIN_SRC emacs-lisp
(setq switch-org-and-elisp-map (make-sparse-keymap))

(define-minor-mode switch-org-and-elisp-mode
  ""
  nil
  nil
  switch-org-and-elisp-map)
(define-key switch-org-and-elisp-map (kbd "C-c m")
  (lambda () (interactive)
    (if (string= 'emacs-lisp-mode major-mode)
        (progn (org-mode) (switch-org-and-elisp-mode t))
      (progn (emacs-lisp-mode) (switch-org-and-elisp-mode t)))
    ))
;; Local Variables:
;; eval: (switch-org-and-elisp-mode 1)
;; End:
#+END_SRC
*** TRAMP
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
(add-to-list 'tramp-remote-path "~/bin")
(setq tramp-use-ssh-controlmaster-options nil)
(global-set-key (kbd "<f5>") 'tramp-cleanup-all-connections)
(setq auto-revert-remote-files t)
(setq vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))
(keychain-refresh-environment)
#+END_SRC

** Emacs server
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
