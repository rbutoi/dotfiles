* Emacs settings

** Loading stuff/setup

#+BEGIN_SRC emacs-lisp
(package-initialize)

(if (eq system-type 'darwin)
    (require 'cask "/usr/local/Cellar/cask/0.7.4/cask.el")
  (require 'cask "~/.cask/cask.el"))
  
(cask-initialize)
(require 'pallet)
(pallet-mode t)

(add-to-list 'load-path "~/.emacs.d/lisp/")
(when (locate-library "arista") (load-library "arista"))

(setq custom-file "~/.emacs.d/custom.el")
(when (file-readable-p custom-file) (load custom-file))
#+END_SRC

** UI

*** Theme
#+BEGIN_SRC emacs-lisp
(load-theme 'solarized t)

;; light in GUI, dark in terminal
(add-hook 'after-make-frame-functions
          (lambda (frame)
            (let ((mode (if (display-graphic-p frame) 'light 'dark)))
              (set-frame-parameter frame 'background-mode mode)
              (set-terminal-parameter frame 'background-mode mode))
            (enable-theme 'solarized)))

;; make window divider prettier
(let ((display-table (or standard-display-table (make-display-table))))
  (set-display-table-slot display-table 'vertical-border (make-glyph-code ?â”‚))
  (setq standard-display-table display-table))

(set-frame-parameter (selected-frame) 'alpha '(95 95))
#+END_SRC

*** Files
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/\\1" t)))
(global-set-key (kbd "C-c r") 'revert-buffer)
(global-auto-revert-mode 1)
(setq vc-follow-symlinks t)
(setq-default save-place t)
(setq save-place-file "~/.emacs.d/saved-places")
(setq recentf-max-saved-items 1000)
(setq recentf-save-file "~/.emacs.d/recentf")
#+END_SRC

*** Buffers
#+BEGIN_SRC emacs-lisp
(setq aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?o))
(global-set-key (kbd "M-o") 'ace-window)
(global-set-key (kbd "C-x o") 'ace-window)
(global-set-key (kbd "M-k") 'kill-this-buffer)

(global-set-key (kbd "M-0") 'delete-window)
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'split-window-below)
(global-set-key (kbd "M-3") 'split-window-right)
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp
;; Helm
(require 'helm)
(require 'helm-config)
(setq helm-buffer-max-length 30)
(setq helm-grep-default-command
      "ack -Hn --color --smart-case --no-group %p %f"
      helm-grep-default-recurse-command
      "ack -H --color --smart-case --no-group %p %f")

(global-set-key (kbd "C-c h") 'helm-command-prefix)
(define-key helm-map (kbd "C-k") 'helm-execute-persistent-action)
(global-unset-key (kbd "C-x c"))
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-m") 'helm-M-x)
(global-set-key (kbd "C-x m") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-b") 'helm-mini)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-o") 'helm-semantic-or-imenu)
(global-set-key (kbd "C-h a") 'helm-apropos)
(global-set-key (kbd "C-M-o") 'helm-swoop)
(global-set-key (kbd "C-c C-M-o") 'helm-multi-swoop)
(helm-descbinds-mode t)

(helm-mode 1)
#+END_SRC

*** Save window geometry
#+BEGIN_SRC emacs-lisp
(defun save-framegeometry ()
  "Gets the current frame's geometry and saves to ~/.emacs.d/framegeometry."
  (let (
        (framegeometry-left (frame-parameter (selected-frame) 'left))
        (framegeometry-top (frame-parameter (selected-frame) 'top))
        (framegeometry-width (frame-parameter (selected-frame) 'width))
        (framegeometry-height (frame-parameter (selected-frame) 'height))
        (framegeometry-file (expand-file-name "~/.emacs.d/framegeometry"))
        )

    (when (not (number-or-marker-p framegeometry-left))
      (setq framegeometry-left 0))
    (when (not (number-or-marker-p framegeometry-top))
      (setq framegeometry-top 0))
    (when (not (number-or-marker-p framegeometry-width))
      (setq framegeometry-width 0))
    (when (not (number-or-marker-p framegeometry-height))
      (setq framegeometry-height 0))

    (with-temp-buffer
      (insert
       ";;; This is the previous emacs frame's geometry.\n"
       ";;; Last generated " (current-time-string) ".\n"
       "(setq initial-frame-alist\n"
       "      '(\n"
       (format "        (top . %d)\n" (max framegeometry-top 0))
       (format "        (left . %d)\n" (max framegeometry-left 0))
       (format "        (width . %d)\n" (max framegeometry-width 0))
       (format "        (height . %d)))\n" (max framegeometry-height 0)))
      (when (file-writable-p framegeometry-file)
        (write-file framegeometry-file))))
  )

(defun load-framegeometry ()
  "Loads ~/.emacs.d/framegeometry which should load the previous frame's geometry."
  (let ((framegeometry-file (expand-file-name "~/.emacs.d/framegeometry")))
    (when (file-readable-p framegeometry-file)
      (load-file framegeometry-file)))
  )

;; Special work to do ONLY when there is a window system being used
(if window-system
    (progn
      (add-hook 'after-init-hook 'load-framegeometry)
      (add-hook 'kill-emacs-hook 'save-framegeometry))
  )
#+END_SRC

*** rich-majority-mode
#+BEGIN_SRC emacs-lisp
(rich-minority-mode 1)
; (setq rm-whitelist "\\[")
(setq rm-whitelist "@") ; this is cool now
; (setq rm-whitelist "nothing")
#+END_SRC

*** big-fringe-mode
#+BEGIN_SRC emacs-lisp
(defvar big-fringe-mode nil)
(define-minor-mode big-fringe-mode
  "Minor mode to use big fringe in the current buffer."
  :init-value nil
  :global t
  :variable big-fringe-mode
  :group 'editing-basics
  (if (not big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
           ; + 4 determined empirically
           (* (+ 4 fill-column) (frame-char-width)))
        2))))
#+END_SRC

*** which-key-mode
#+BEGIN_SRC emacs-lisp
(define-globalized-minor-mode global-which-key-mode
  which-key-mode (lambda () (which-key-mode)))
(global-which-key-mode)
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
(tool-bar-mode -1)
;; (scroll-bar-mode -1)
(unless (and (eq system-type 'darwin) (display-graphic-p)) (menu-bar-mode -1))

(fset 'yes-or-no-p 'y-or-n-p)
(setq x-select-enable-clipboard t
      x-select-enable-primary t
      save-interprogram-paste-before-kill t
      apropos-do-all t
      mouse-yank-at-point t)

(blink-cursor-mode 0)

(setq ns-command-modifier (quote control))
#+END_SRC

** Editing

*** M-{n,p} for paragraph movement
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)
#+END_SRC

*** jcs-comment-box
#+BEGIN_SRC emacs-lisp
(defun jcs-comment-box (b e)
  "Draw a box comment around the region but arrange for the region
to extend to at least the fill column. Place the point after the
comment box."
  (interactive "r")
  (save-restriction
    (narrow-to-region b e)
    (goto-char b)
    (end-of-line)
    (insert-char ?  (- fill-column (current-column)))
    (comment-box b (point-max) 1)
    (goto-char (point-max))))
#+END_SRC

*** Newline indents
#+BEGIN_SRC emacs-lisp
(clean-aindent-mode t)
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Undo tree
#+BEGIN_SRC emacs-lisp
(setq undo-tree-visualizer-timestamps t)
(setq undo-tree-visualizer-diff t)
(global-undo-tree-mode 1)
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
;; flyspell needs location of aspell on Mac
(setq ispell-list-command "--list")
(when (eq system-type 'darwin)
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
  (setq exec-path (append exec-path '("/usr/local/bin"))))
(add-hook 'org-journal-mode-hook 'flyspell-mode)
; (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

*** comment-or-uncomment-line-or-region
#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
(global-set-key (kbd "M-[ q") 'comment-or-uncomment-line-or-region)
; (global-set-key (kbd "C-;") 'comment-or-uncomment-line-or-region)
(global-set-key [remap comment-dwim] 'comment-or-uncomment-line-or-region)
#+END_SRC

*** exchange-point-and-mark-no-activate
#+BEGIN_SRC emacs-lisp
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(global-set-key (kbd "C-x C-x") 'exchange-point-and-mark-no-activate)
#+END_SRC

*** Better C-w
#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

*** Better C-{a,e}
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-a") 'mwim-beginning-of-code-or-line)
(global-set-key (kbd "C-e") 'mwim-end-of-code-or-line)
#+END_SRC

*** can keep C-u C-SPC C-SPC C-SPC
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

*** highlight-symbol-mode
#+BEGIN_SRC emacs-lisp
;; I have a feeling this is laggy, and its more or less replaced by occur at point
;; (define-globalized-minor-mode global-highlight-symbol-mode
;;   highlight-symbol-mode (lambda () (progn (highlight-symbol-mode) (highlight-symbol-nav-mode))))
;; (setq highlight-symbol-idle-delay 0.5)
;; (global-highlight-symbol-mode)
#+END_SRC

*** Truncate lines
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c s")   'toggle-truncate-lines)
(global-set-key (kbd "C-c C-s") 'toggle-truncate-lines)
(set-default 'truncate-lines t)
#+END_SRC

*** zap-up-to-char
#+BEGIN_SRC emacs-lisp
(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.
  
  \(fn arg char)"
  'interactive)
(global-set-key (kbd "M-Z") 'zap-up-to-char)
#+END_SRC

*** ace-isearch-mode
#+BEGIN_SRC emacs-lisp
(setq ace-isearch-use-jump nil)
(global-ace-isearch-mode t)
#+END_SRC

*** org
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "C-M-u") 'org-up-element)
(setq org-startup-folded nil)
#+END_SRC

*** org-journal
#+BEGIN_SRC emacs-lisp
(setq org-journal-date-format "%A, %d/%m/%Y")
(setq sorg-journal-file-format "%Y%m%d.txt")
(setq org-journal-dir "~/Google Drive/journal/")
(setq org-journal-hide-entries-p nil)
(setq org-journal-find-file 'find-file)
; fill file before saving
(add-hook 'org-journal-mode-hook
          (lambda ()
            (add-hook 'before-save-hook
                      (lambda()
                        (fill-region (point-min) (point-max))) nil t)))
; whitespace-mode is fairly useless in org-journal. remap its key to set the
; frame with to the fillcolumn + empirical value
(add-hook 'org-journal-mode-hook
          (lambda ()
            (define-key org-journal-mode-map (kbd "C-c w")
              (lambda () (interactive)
                (set-frame-width (selected-frame) (+ 1 fill-column))))))
(defun set-frame-width-interactive (arg)
  (interactive "nFrame width: ")
  (set-frame-width (selected-frame) arg))
#+END_SRC

*** Misc
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
(setq-default fill-column 80)
(delete-selection-mode 1)
(setq diff-switches "-u")
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Programming

*** Languages

**** Python
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'anaconda-mode)
; because python-mode overwrites it
(add-hook 'python-mode-hook
 (lambda () (add-to-list 'completion-at-point-functions 'company-complete)))

;; using flymake since it works with pylint < 1.0.0
(require 'flymake)

(defun flymake-pylint-init ()
  (let* ((temp-file (flymake-init-create-temp-buffer-copy
                     'flymake-create-temp-inplace))
         (local-file (file-relative-name
                      temp-file
                      (file-name-directory buffer-file-name))))
    (list "epylint" (list local-file))))
(add-to-list 'flymake-allowed-file-name-masks
             '("\\.py\\'" flymake-pylint-init))
(add-hook 'python-mode-hook
          (lambda()
            (define-prefix-command 'fake-flycheck-map)
            (local-set-key (kbd "C-c !") 'fake-flycheck-map)
            (local-set-key (kbd "C-c ! h") 'flymake-popup-current-error-menu)
            (local-set-key (kbd "C-c ! n") 'flymake-goto-next-error)
            (local-set-key (kbd "C-c ! p") 'flymake-goto-prev-error)
            (flymake-mode)
))
#+END_SRC

**** Perl
#+BEGIN_SRC emacs-lisp
(add-hook 'perl-mode-hook (lambda () (progn
                                       (define-key perl-mode-map (kbd "C-c C-d") 'cperl-perldoc)
                                       )))
#+END_SRC

**** ASM mode
#+BEGIN_SRC emacs-lisp
(eval-after-load 'asm-mode
  '(define-key asm-mode-map [(tab)] 'asm-indent-line))
#+END_SRC

**** Makefile
#+BEGIN_SRC emacs-lisp
(add-hook 'makefile-mode-hook (lambda () (setq indent-tabs-mode t)))

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.vt\\'" . verilog-mode))
#+END_SRC

**** C-like
***** Semantic
#+BEGIN_SRC emacs-lisp
;; (semantic-mode)
;; (global-semantic-stickyfunc-mode)
#+END_SRC

***** No namespace intent
#+BEGIN_SRC emacs-lisp
(defun no-ns-indent ()
   (c-set-offset 'innamespace [0]))
(add-hook 'c++-mode-hook 'no-ns-indent)
#+END_SRC

***** Find other file
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda() 
            (local-set-key (kbd "C-c o") 'projectile-find-other-file)
            (local-set-key (kbd "C-c C-o") 'projectile-find-other-file)
            ))
#+END_SRC

*** Flycheck
#+BEGIN_SRC emacs-lisp
(add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
(add-hook 'rust-mode-hook 'flycheck-mode)
(add-hook 'perl-mode-hook 'flycheck-mode)
#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
(global-company-mode 1)
(eval-after-load "company"
  '(add-to-list 'company-backends 'company-anaconda))
(setq tab-always-indent 'complete)
(setq company-require-match nil)
(setq company-idle-delay nil)
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
(add-hook 'projectile-mode-hook
          (lambda ()
            (define-key projectile-mode-map (kbd "C-c C-p") 'projectile-command-map)))
(setq projectile-mode-line
   (quote
    (:eval
     (if
         (file-remote-p default-directory)
         ""
       (format " \@%s"
               (projectile-project-name))))))
(setq projectile-completion-system 'helm)
(projectile-global-mode)
(helm-projectile-on)
#+END_SRC

*** which-function-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'which-function-mode)
#+END_SRC

*** compiling
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (global-set-key (kbd "<f7>")   'compile)))
(add-hook 'prog-mode-hook (lambda () (global-set-key (kbd "<f8>") 'recompile)))
(setq compilation-message-face 'default)
#+END_SRC

*** Line numbers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'nlinum-mode)
#+END_SRC

*** Show parens 
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (progn
                                       (show-paren-mode 1)
                                       (setq show-paren-delay 0))))
#+END_SRC

*** Indent
#+BEGIN_SRC emacs-lisp
;; guess offset don't need the global modeline
(dtrt-indent-mode 1)
(add-hook 'prog-mode-hook (lambda() (delete 'dtrt-indent-mode-line-info global-mode-string)))

(setq-default indent-tabs-mode nil)
(setq c-default-style "linux")
(if (locate-library "arista") (setq c-basic-offset 3) (setq c-basic-offset 4))
;; (add-to-list 'c-offsets-alist '(arglist-close . c-linup-close-paren))
#+END_SRC

*** whitespace-mode
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC

*** yafolding-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'yafolding-mode)
(define-key yafolding-mode-map (kbd "<C-S-return>") nil)
(define-key yafolding-mode-map (kbd "<C-M-return>") nil)
(define-key yafolding-mode-map (kbd "<C-return>") nil)
(define-key yafolding-mode-map (kbd "M-RET") 'yafolding-toggle-element)
#+END_SRC

** Meta/misc

*** When editing this file, C-c m to switch between org-mode and elisp. Yup...
#+BEGIN_SRC emacs-lisp
(setq switch-org-and-elisp-map (make-sparse-keymap))

(define-minor-mode switch-org-and-elisp-mode
  ""
  nil
  nil
  switch-org-and-elisp-map)
(define-key switch-org-and-elisp-map (kbd "C-c m")
  (lambda () (interactive)
    (if (string= 'emacs-lisp-mode major-mode)
        (progn (org-mode) (switch-org-and-elisp-mode t))
      (progn (emacs-lisp-mode) (switch-org-and-elisp-mode t)))
    ))

;; Local Variables:
;; eval: (switch-org-and-elisp-mode 1)
;; End:
#+END_SRC
** Emacs server
#+BEGIN_SRC emacs-lisp
;; (when (getenv "EMACS_SESSION_DIR") (setq server-socket-dir (getenv "EMACS_SESSION_DIR")))
(server-start)
#+END_SRC

