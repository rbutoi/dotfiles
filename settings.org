* Loading stuff/setup

#+BEGIN_SRC emacs-lisp
(package-initialize)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
(setq use-package-verbose t
      use-package-always-ensure t)
(require 'bind-key)
#+END_SRC

* UI

** Theme
#+BEGIN_SRC emacs-lisp
(use-package solarized-theme
  :bind (("C-x 7" . toggle-theme)
         ("C-x C-7" . toggle-theme)
         ("C-x C-_" . toggle-theme))
  :init
  (setq next-bg 'dark)

  (defun themed-mode ()
    (interactive)
    (when (eq next-bg 'dark)
      (load-theme 'solarized-dark t)
      (setq next-bg 'off)))
  (defun unthemed-mode ()
    (interactive)
    (when (eq next-bg 'off)
      (disable-theme 'solarized-dark)
      (setq next-bg 'dark)))

  ;; toggle dark/light for when switching graphical to terminal
  (defun toggle-theme ()
    (interactive)
    (cond ((eq next-bg 'dark)
           (themed-mode))
          ((eq next-bg 'off)
           (unthemed-mode)))

    ;; a bit more contrast to keep track of curent window
    (set-face-attribute  'mode-line
                         nil
                         :box '(:line-width 3 :style released-button))
    (set-face-attribute  'mode-line-inactive
                         nil
                         :box nil))
  ;; needed to prevent errors, even if staying unthemed
  (themed-mode)

  (defun themed-if-window-system (frame)
    (if (window-system frame) (themed-mode) (unthemed-mode)))
  (add-hook 'after-make-frame-functions 'themed-if-window-system)
  (add-hook 'focus-in-hook (lambda () (themed-if-window-system (selected-frame))))
  (themed-if-window-system (selected-frame))
  )

;; transparency
(add-to-list 'default-frame-alist '(alpha 92 92))

;; font
;; why does mac need this?
(add-to-list 'default-frame-alist '(font . "Monaco-10"))
(when (eq system-type 'darwin) (set-frame-font "Monaco-10"))


;; make window divider prettier
(let ((display-table (or standard-display-table (make-display-table))))
  (set-display-table-slot display-table 'vertical-border (make-glyph-code ?â”‚))
  (setq standard-display-table display-table))

(eval-after-load 'hl-line
  (lambda () (set-face-attribute 'hl-line nil)))
(eval-after-load 'which-func
  (lambda () (set-face-attribute 'which-func nil :foreground "dark cyan")))

#+END_SRC

** rich-minority-mode
#+BEGIN_SRC emacs-lisp
(use-package rich-minority
  :config
  (setq rm-whitelist
        (format "^ \\(%s\\)$"
                (mapconcat #'identity
                           '("Fly.*" "Ace*")
                           "\\|")))
  (rich-minority-mode t)
  )
#+END_SRC

** Buffers and windows
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("C-x o" . ace-window)
         ("C-x C-o" . ace-window))
  :config
  (setq aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?o)))

(defun kill-all-buffers ()
  "Kill all buffers."
  (interactive)
  (mapc 'kill-buffer (buffer-list))
  (delete-other-windows)
  (message "Killed all buffers"))
(defun kill-other-buffers ()
  "Kill all other buffers."
  (interactive)
  (mapc 'kill-buffer
        (delq (current-buffer)
              (remove-if-not 'buffer-file-name (buffer-list))))
  (message "Killed other buffers"))
(defun kill-matching-buffers-just-do-it ()
  "Kill buffers whose names match REGEXP, without asking."
  (interactive)
  (cl-letf (((symbol-function 'kill-buffer-ask) #'kill-buffer))
    (call-interactively #'kill-matching-buffers)))

(defun m-buffer-binds (m)
  (bind-keys :map m
             ("M-o" . other-window)
             ("M-i" . (lambda () (interactive) (other-window -1)))
             ("M-l" . (lambda () (interactive) (select-window (get-mru-window t t t))))
             ("C-k" . kill-current-buffer)
             ("C-S-k" . kill-other-buffers)
             ("C-M-k" . kill-other-buffers) ;; for when in terminal
             ("C-M-C" . save-buffers-kill-emacs)
             ("M-0" . (lambda () (interactive) (delete-window)))
             ("M-1" . (lambda () (interactive) (delete-other-windows)))
             ("M-2" . (lambda () (interactive) (split-window-below)))
             ("M-3" . (lambda () (interactive) (split-window-right)))))
(m-buffer-binds (current-global-map))
;; instead of the hacky putting (balance-windows) after all those commands:
(defadvice split-window-below (after restore-balanace-below activate)
  (balance-windows))
(defadvice split-window-right (after restore-balance-right activate)
  (balance-windows))
(defadvice delete-window (after restore-balance activate)
  (balance-windows))

(use-package zoom-window :bind (("C-x C-z" . zoom-window-zoom)))

(setq split-height-threshold nil
      split-width-threshold 120)

(use-package buffer-move
  :bind (("<C-S-up>" . buf-move-up)
         ("<C-S-down>" . buf-move-down)
         ("<C-S-left>" . buf-move-left)
         ("<C-S-right>" . buf-move-right)))
#+END_SRC

** Files
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      auto-save-file-name-transforms '((".*" "~/.emacs.d/backups/\\1" t)))

(bind-key "C-c r" 'revert-buffer)
(bind-key "C-c C-r" 'revert-buffer)
(global-auto-revert-mode 1)
(defun modi/revert-all-file-buffers ()
  "Refresh all open file buffers without confirmation.
Buffers in modified (not yet saved) state in emacs will not be
reverted. They will be reverted though if they were modified
outside emacs. Buffers visiting files which do not exist any more
or are no longer readable will be killed."
  (interactive)
  (dolist (buf (buffer-list))
    (let ((filename (buffer-file-name buf)))
      ;; Revert only buffers containing files, which are not modified;
      ;; do not try to revert non-file buffers like *Messages*.
      (when (and filename
                 (not (buffer-modified-p buf)))
        (if (file-readable-p filename)
            ;; If the file exists and is readable, revert the buffer.
            (with-current-buffer buf
              (revert-buffer :ignore-auto :noconfirm :preserve-modes))
          ;; Otherwise, kill the buffer.
          (let (kill-buffer-query-functions) ; No query done when killing buffer
            (kill-buffer buf)
            (message "Killed non-existing/unreadable file buffer: %s" filename))))))
  (message "Finished reverting buffers containing unmodified files."))
(bind-key "C-c R" 'modi/revert-all-file-buffers)

(setq-default save-place t)
(setq save-place-file "~/.emacs.d/saved-places")

;; Recentf
(setq recentf-max-saved-items 1000
      recentf-save-file "~/.emacs.d/recentf")
(customize-set-variable 'recentf-auto-cleanup 'never)
(recentf-mode t)
(run-at-time (current-time) 300 'recentf-save-list)
#+END_SRC

** Helm
#+BEGIN_SRC emacs-lisp
(use-package helm
  :defer 1
  :bind (("C-c h" . helm-command-prefix)
         ("M-x" . helm-M-x)
         ("C-x m" . helm-M-x)
         ("C-x C-m" . helm-M-x)
         ("M-y" . helm-show-kill-ring)
         ("C-x b" . helm-mini)
         ("C-x C-b" . mode-line-other-buffer)
         ("C-x C-f" . helm-find-files)
         ("C-x f" . find-file)
         ("C-o" . helm-semantic-or-imenu)
         ("C-h a" . helm-apropos)
         ("C-M-o" . helm-swoop)
         :map helm-map
         ("C-k" . helm-execute-persistent-action))
  :config
  (require 'helm-config)
  (helm-mode t)

  ;; get dependencies. idk if this nested thing is good but whatever
  (use-package helm-swoop)
  (use-package helm-descbinds :config (helm-descbinds-mode t))
  (use-package helm-rg :bind (("C-M-s" . helm-rg)))

  (setq helm-buffer-skip-remote-checking t
        helm-split-window-default-side 'same
        helm-buffer-max-length nil)

  (unbind-key "C-x c"))
#+END_SRC

** Save window geometry
#+BEGIN_SRC emacs-lisp
(defun save-framegeometry ()
  "Gets the current frame's geometry and saves to ~/.emacs.d/framegeometry."
  (let ((framegeometry-left (frame-parameter (selected-frame) 'left))
        (framegeometry-top (frame-parameter (selected-frame) 'top))
        (framegeometry-width (frame-parameter (selected-frame) 'width))
        (framegeometry-height (frame-parameter (selected-frame) 'height))
        (framegeometry-file (expand-file-name "~/.emacs.d/framegeometry")))

    (when (not (number-or-marker-p framegeometry-left))
      (setq framegeometry-left 0))
    (when (not (number-or-marker-p framegeometry-top))
      (setq framegeometry-top 0))
    (when (not (number-or-marker-p framegeometry-width))
      (setq framegeometry-width 0))
    (when (not (number-or-marker-p framegeometry-height))
      (setq framegeometry-height 0))

    (with-temp-buffer
      (insert
       ";;; This is the previous emacs frame's geometry.\n"
       ";;; Last generated " (current-time-string) ".\n"
       "(setq initial-frame-alist\n"
       "      '(\n"
       (format "        (top . %d)\n" (max framegeometry-top 0))
       (format "        (left . %d)\n" (max framegeometry-left 0))
       (format "        (width . %d)\n" (max framegeometry-width 0))
       (format "        (height . %d)))\n" (max framegeometry-height 0)))
      (when (file-writable-p framegeometry-file)
        (write-file framegeometry-file)))))

(defun load-framegeometry ()
  "Loads ~/.emacs.d/framegeometry which should load the previous frame's geometry."
  (let ((framegeometry-file (expand-file-name "~/.emacs.d/framegeometry")))
    (when (file-readable-p framegeometry-file)
      (load-file framegeometry-file))))

(add-hook 'after-init-hook 'load-framegeometry)
(add-hook 'kill-emacs-hook 'save-framegeometry)
#+END_SRC

** big-fringe-mode
#+BEGIN_SRC emacs-lisp
(defvar big-fringe-mode nil)
(define-minor-mode big-fringe-mode
  "Minor mode to use big fringe in the current buffer."
  :init-value nil
  :global t
  :variable big-fringe-mode
  :group 'editing-basics
  (if (not big-fringe-mode)
      (set-fringe-style nil)
    (set-fringe-mode
     (/ (- (frame-pixel-width)
           ;; + 4 determined empirically
           (* (+ 4 fill-column) (frame-char-width)))
        2))))
#+END_SRC

** which-key-mode
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (define-globalized-minor-mode global-which-key-mode
    which-key-mode (lambda () (which-key-mode)))
  (global-which-key-mode))
#+END_SRC

** fill-column-indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator)
#+END_SRC

** pos-tip
#+BEGIN_SRC emacs-lisp
(use-package pos-tip)
#+END_SRC

** Hide UI elements
#+BEGIN_SRC emacs-lisp
(column-number-mode 1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(unless (and (eq system-type 'darwin) (display-graphic-p)) (menu-bar-mode -1))
(blink-cursor-mode 0)
#+END_SRC

** Copy paste
#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard t
      x-select-enable-primary t
      x-select-enable-clipboard-manager nil
      save-interprogram-paste-before-kill t
      mouse-yank-at-point t)
#+END_SRC

** garbage collection
#+BEGIN_SRC emacs-lisp
(setq garbage-collection-messages t)

(defconst GC-MEGS 100)
(setq gc-cons-threshold (* 1024 1024 GC-MEGS))
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold (* 1024 1024 GC-MEGS)))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)

#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setq apropos-do-all t)

(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(setq ns-command-modifier 'control)

#+END_SRC
* Editing

** M-{n,p} for paragraph movement
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-p" . backward-paragraph)
           ("M-n" . forward-paragraph))
#+END_SRC

** Undoing, undo tree
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :bind (("C-z" . undo)
         ("C-x C-u" . undo-tree-visualize)
         ("C-x u" . undo-tree-visualize))
  :config
  (setq undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t)
  (global-undo-tree-mode 1))
#+END_SRC

** Flyspell
#+BEGIN_SRC emacs-lisp
;; (unless (eq system-type 'darwin)
;; (use-package flyspell :hook ((org-journal-mode . flyspell-mode)
;; (prog-mode . flyspell-prog-mode))))
#+END_SRC

** comment-or-uncomment-line-or-region
#+BEGIN_SRC emacs-lisp
(defun comment-or-uncomment-line-or-region ()
  "Comments or uncomments the current line or region."
  (interactive)
  (if (region-active-p)
      (comment-or-uncomment-region (region-beginning) (region-end))
    (progn
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
      (forward-line))))
(bind-key "M-[ q" 'comment-or-uncomment-line-or-region)
(bind-key [remap comment-dwim] 'comment-or-uncomment-line-or-region)
#+END_SRC

** exchange-point-and-mark-no-activate
#+BEGIN_SRC emacs-lisp
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(bind-key "C-x C-x" 'exchange-point-and-mark-no-activate)
#+END_SRC

** Better C-w
#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-ring-save (before slick-cut activate compile)
  "When called interactively with no active region, save a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

** Better C-{a,e}
#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind (("C-a" . mwim-beginning-of-code-or-line)
         ("C-a" . mwim-beginning-of-code-or-line)
         ("C-e" . mwim-end-of-code-or-line)
         ("<home>" . mwim-beginning-of-code-or-line)
         ("<end>" . mwim-end-of-code-or-line))
  :config
  (setq mwim-beginning-of-line-function 'beginning-of-line)
  (setq mwim-end-of-line-function 'end-of-line))
#+END_SRC

** can keep C-u C-SPC C-SPC C-SPC
#+BEGIN_SRC emacs-lisp
(setq set-mark-command-repeat-pop t)
#+END_SRC

** Truncate lines
#+BEGIN_SRC emacs-lisp
(bind-keys ("C-c s" . toggle-truncate-lines)
           ("C-c C-s" . toggle-truncate-lines))
(add-hook 'c-mode-common-hook
	      (lambda ()
	        (bind-key "C-c C-s" 'toggle-truncate-lines c-mode-base-map)))

(add-hook 'prog-mode-hook
          (lambda ()
            (toggle-truncate-lines t)))
#+END_SRC

** zap-to-char
#+BEGIN_SRC emacs-lisp
(bind-keys ("M-z" . zap-to-char)
           ("C-M-z" . zap-up-to-char))
#+END_SRC

** just-one-space
#+BEGIN_SRC emacs-lisp
;; to get around xmonad
(bind-key "C-M-SPC" 'just-one-space)
#+END_SRC

** org
#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (:map org-mode-map ("C-M-u" . org-up-element))
  :hook (org-mode . (lambda () (m-buffer-binds (current-local-map))))
  :config
  (setq org-startup-folded nil)
  #+END_SRC

  ** org-journal
  #+BEGIN_SRC emacs-lisp
  (use-package org-journal
    :custom (org-journal-dir "~/google-drive/journal/")
    :config
    (setq org-journal-date-format "%A, %d/%m/%Y")
    (setq sorg-journal-file-format "%Y%m%d.txt")
    (setq org-journal-hide-entries-p nil)
    (setq org-journal-find-file 'find-file)
    (add-hook 'org-journal-mode-hook 'auto-fill-mode)
    ;; whitespace-mode is fairly useless in org-journal. remap its key to set the
    ;; frame with to the fillcolumn + empirical value
    (add-hook 'org-journal-mode-hook
              (lambda ()
                (bind-key "C-c w"
                          (lambda () (interactive) (set-frame-width (selected-frame) (+ 1 fill-column)))
                          org-journal-mode-map)
                (bind-key "<f7>"
                          (lambda () (interactive)
                            (async-shell-command "yes Y | drive push"))
                          org-journal-mode-map)))))

(defun set-frame-width-interactive (arg)
  (interactive "nFrame width: ")
  (set-frame-width (selected-frame) arg))
#+END_SRC

** Copy current path name
#+BEGIN_SRC emacs-lisp
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

** electric-pair-mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode)
#+END_SRC

** visual-line-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC

** ztree
#+BEGIN_SRC emacs-lisp
(use-package ztree
  :config
  (setq ztree-draw-unicode-lines t))
#+END_SRC

** string-inflection
#+BEGIN_SRC emacs-lisp
(use-package string-inflection :config (bind-key* "C-c C-u" 'string-inflection-cycle))
#+END_SRC

** goto-address-mode
#+BEGIN_SRC emacs-lisp
(define-globalized-minor-mode global-goto-address-mode
  goto-address-mode (lambda () (goto-address-mode)))
(global-goto-address-mode t)
#+END_SRC

** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("M-=" . er/expand-region))
#+END_SRC

** Misc
#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)

(setq-default fill-column 80)
(setq sentence-end-double-space nil)

(delete-selection-mode 1)
(put 'narrow-to-region 'disabled nil)

;; fix for school computers
(when (string-match-p "eecg" system-name) (normal-erase-is-backspace-mode 0))

;; swap query replace keys so regexp is available in terminal
(bind-keys ("C-M-%" . query-replace)
           ("M-%" . query-replace-regexp))
#+END_SRC

* Programming

** Languages

*** Perl
#+BEGIN_SRC emacs-lisp
(add-hook 'perl-mode-hook
          (lambda () (progn (bind-key "C-c C-d" 'cperl-perldoc perl-mode-map))))
#+END_SRC

*** ASM mode
#+BEGIN_SRC emacs-lisp
(eval-after-load 'asm-mode
  '(bind-key [tab] 'asm-indent-line asm-mode-map))
#+END_SRC

*** Makefile
#+BEGIN_SRC emacs-lisp
(add-hook 'makefile-mode-hook (lambda () (setq indent-tabs-mode t)))

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.vt\\'" . verilog-mode))
#+END_SRC

*** Conf-mode
#+BEGIN_SRC emacs-lisp
(dolist (hook '(conf-unix-mode-hook conf-space-mode-hook))
  (add-hook hook (lambda () (run-mode-hooks 'prog-mode-hook))))
#+END_SRC

*** C-like
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
	      (lambda ()
	        (electric-pair-local-mode)
	        (bind-key "C-c C-o" (lambda () (interactive) (ff-find-other-file nil t))
                      c-mode-base-map)))

#+END_SRC

*** LaTeX
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook
          (lambda ()
            (setq TeX-auto-untabify t     ;; remove all tabs before saving
                  ;; TeX-view-program-list '(("LLPP" "killall -SIGHUP llpp || llpp %o"))
                  TeX-view-program-list '(("Xreader" "xreader %o"))
                  TeX-view-program-selection '((output-pdf "Xreader")))
            (setq TeX-command-force "LaTeX")))
#+END_SRC

*** rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode)
(use-package racer
  :config
  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
  (setq racer-rust-src-path "/home/radu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"))
#+END_SRC

*** pkgbuild
#+BEGIN_SRC emacs-lisp
(use-package pkgbuild-mode)
#+END_SRC

*** yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :config
  (add-hook 'yaml-mode-hook (lambda () (run-mode-hooks 'prog-mode-hook))))
#+END_SRC

*** json
#+BEGIN_SRC emacs-lisp
(use-package json-mode)
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :init (global-company-mode)
  :config
  (defun setup-company-c/c++ ()
    (bind-key "TAB" 'company-indent-or-complete-common c-mode-base-map))
  (add-hook 'c-mode-common-hook 'setup-company-c/c++)
  (bind-key "TAB" 'company-indent-or-complete-common)

  (setq
   tab-always-indent 'complete
   company-dabbrev-downcase nil)

  ;; low-tech alternative
  (bind-keys ("C-<tab>" . dabbrev-expand)
             ("M-/" . dabbrev-expand)))
#+END_SRC

** No namespace intent
#+BEGIN_SRC emacs-lisp
(defun no-ns-indent ()
  (c-set-offset 'innamespace [0]))
(add-hook 'c++-mode-hook 'no-ns-indent)
#+END_SRC

** Diffing
#+BEGIN_SRC emacs-lisp
(add-hook 'diff-mode-hook (lambda ()
                            (m-buffer-binds (current-local-map))
                            (read-only-mode t)))
(setq diff-switches "-u")
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(eval-after-load 'ediff
  '(progn
     (set-face-foreground 'ediff-fine-diff-A "white")
     (set-face-foreground 'ediff-fine-diff-B "white")))

(bind-key "C-x C-v" 'vc-prefix-map)
#+END_SRC

** diff-hl-mode
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :defer 1
  :bind (("C-x C-v ]" . diff-hl-next-hunk)
         ("C-x C-v [" . diff-hl-previous-hunk)
         ("C-x C-v n" . diff-hl-revert-hunk)
         ("C-x C-v a" . global-diff-hl-amend-mode)
         ("C-x C-v C-a" . global-diff-hl-amend-mode)
         )
  :config
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  ;; TODO figure out margin mode toggling with toggle-theme that doesn't cause
  ;; void-variable errors and such
  (diff-hl-margin-mode t)
  (global-diff-hl-mode)
  (bind-keys
   ("C-x C-v =" . vc-diff)
   ("C-x v   =" . vc-diff)))
#+END_SRC

** hl-line-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

** compiling
#+BEGIN_SRC emacs-lisp
(defun close-compile-window-if-successful (buffer string)
  " close a compilation window if succeeded without warnings "
  (if (and
       (string-match "compilation" (buffer-name buffer))
       (string-match "finished" string)
       (not
        (with-current-buffer buffer
          (search-forward "warning" nil t))))
      (run-with-timer 1 nil
                      (lambda (window) (quit-window nil window))
                      (get-buffer-window buffer))))
(add-hook 'compilation-finish-functions 'close-compile-window-if-successful)

(add-hook 'prog-mode-hook (lambda ()) (bind-key "<f8>" 'recompile))
(setq compilation-message-face 'default)
#+END_SRC

** Line numbers
#+BEGIN_SRC emacs-lisp
(use-package nlinum :bind
  ("C-c l" . nlinum-mode)
  ("C-c C-l" . nlinum-mode))
(add-hook 'c++-mode-hook
          (lambda ()
            (bind-keys :map c++-mode-map
                       ("C-c C-l" . nlinum-mode))))
#+END_SRC

** Parens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :init (require 'smartparens-config)
  :config (smartparens-global-mode 1)
  (bind-keys :map smartparens-mode-map
             ("C-M-f" . sp-forward-sexp)
             ("C-M-b" . sp-backward-sexp)

             ("C-M-e" . sp-up-sexp)
             ("C-M-u" . sp-backward-up-sexp)
             ("C-M-t" . sp-transpose-sexp)

             ("C-M-n" . sp-next-sexp)
             ("C-M-p" . sp-previous-sexp)

             ("M-D" . sp-splice-sexp)

             ("M-F" . sp-forward-symbol)
             ("M-B" . sp-backward-symbol)
             )
  (sp-with-modes '(c-mode c++-mode)
    (sp-local-pair "<" ">"))
  (add-hook 'prog-mode-hook (lambda () (show-paren-mode 1) (setq show-paren-delay 0))))
#+END_SRC

** Indent
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :config
  ;; guess offset don't need the global modeline
  (dtrt-indent-mode 1)
  (add-hook 'prog-mode-hook
            (lambda () (delete 'dtrt-indent-mode-line-info global-mode-string))))

(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
(setq c-default-style "k&r"
      c-basic-offset 4)
#+END_SRC

** whitespace-mode
#+BEGIN_SRC emacs-lisp
(bind-keys ("C-c w" . whitespace-mode)
           ("C-c C-w" . whitespace-mode))
#+END_SRC

** Term
#+BEGIN_SRC emacs-lisp
(use-package sane-term
  :bind (("C-x C-t" . term-into-dir)
         ("C-x t" . term-into-dir-create))
  :config
  (defun term-into-dir-internal (create)
    (let ((cmd ""))
      (when (file-remote-p default-directory)
        (let ((dissected (tramp-dissect-file-name default-directory)))
          (let ((host (tramp-file-name-host dissected))
                (user (concat (tramp-file-name-user dissected)))
                (dir  (tramp-file-name-localname dissected)))
            (when (string= user "@") (setq user ""))
            (setq ssh-cd-command
                  (concat "exec ssh -t " user host " 'cd " dir
                          " && exec bash -l'")))))
      (if create
          (sane-term-create)
        (sane-term))
      (when (file-remote-p default-directory)
        (run-with-timer 0.125 nil (lambda ()
                                    (term-line-mode)
                                    (goto-char (point-max))
                                    (insert ssh-cd-command)
                                    (term-send-input)
                                    (term-char-mode))))))
  (add-hook 'term-mode-hook
            (lambda ()
              (term-set-escape-char ?\C-x)
              (setq term-buffer-maximum-size 20000)
              (toggle-truncate-lines nil)
              (setq bidi-paragraph-direction 'left-to-right)
              ))
  ;; (defun term-send-backwards-delete-word () (interactive)
  ;;        (term-send-raw-string "\C-w"))
  (defun term-send-Mbackspace () (interactive) (term-send-raw-string "\e\d"))

  (eval-after-load 'term
    '(progn
       (bind-keys :map term-raw-map
                  ("<C-backspace>" . term-send-Mbackspace)
                  ("<M-backspace>" . term-send-Mbackspace)
                  ([tab] . (lambda () (interactive) (term-send-raw-string "\t")))
                  :map term-mode-map
                  ("C-x C-k" . term-char-mode)
                  ([tab] . (lambda () (interactive) (term-send-raw-string "\t")))
                  ("C-x C-j" . (lambda nil (interactive))))
       (setq comint-move-point-for-output nil
             comint-scroll-show-maximum-output nil
             term-suppress-hard-newline t
             term-prompt-regexp "^.*[%$] ")
       (m-buffer-binds term-raw-map)
       ))

  (defun term-into-dir (arg)
    (interactive "P")
    (term-into-dir-internal nil))
  (defun term-into-dir-create (arg)
    (interactive "P")
    (term-into-dir-internal t))
  )

;; https://github.com/akermu/emacs-libvterm
(let ((vterm-path (locate-user-emacs-file "lisp/emacs-libvterm")))
  (when (file-exists-p vterm-path)
    (add-to-list 'load-path vterm-path)
    (let (vterm-install)
      (require 'vterm))
    (m-buffer-binds vterm-mode-map)
    ))

(unbind-key "M-!")
(bind-key "C-!" 'shell-command)
#+END_SRC

** subword-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

** auto-fill-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda ()
                            (setq-local comment-auto-fill-only-comments t)
                            (auto-fill-mode 1)))
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (("C-x g" . magit-status)
         ("C-x C-g" . magit-status)))
#+END_SRC

** clang-format
#+BEGIN_SRC emacs-lisp
(use-package clang-format
  :config
  (add-hook 'c-mode-common-hook
            (lambda () (fset 'c-indent-region 'clang-format-region)))
  (add-hook 'before-save-hook
            (lambda () (when (or (eq major-mode 'c++-mode) (eq major-mode 'c-mode))
                         (clang-format-buffer)))))
#+END_SRC

* Meta/misc

** When editing this file, C-c m to switch between org-mode and elisp. Yup...
#+BEGIN_SRC emacs-lisp
(setq switch-org-and-elisp-map (make-sparse-keymap))
(define-minor-mode switch-org-and-elisp-mode "" nil nil switch-org-and-elisp-map)
(defun switch-org-and-elisp () (interactive)
       (if (string= 'emacs-lisp-mode major-mode)
           (progn (org-mode) (switch-org-and-elisp-mode t))
         (progn (emacs-lisp-mode) (switch-org-and-elisp-mode t))))
(bind-key "C-c m" 'switch-org-and-elisp switch-org-and-elisp-map)
(bind-key "C-c C-m" 'switch-org-and-elisp switch-org-and-elisp-map)
;; Local Variables:
;; eval: (switch-org-and-elisp-mode 1)
;; End:
#+END_SRC

** open file in sudo
#+BEGIN_SRC emacs-lisp
(defun open-file-with-sudo ()
  (interactive)
  (find-file (concat "/sudo::" (buffer-file-name))))
#+END_SRC

** TRAMP
#+BEGIN_SRC emacs-lisp
(use-package tramp
  :config
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
  (add-to-list 'tramp-remote-path "~/bin")
  (setq tramp-use-ssh-controlmaster-options nil)
  (setq auto-revert-remote-files t)
  (setq vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)" vc-ignore-dir-regexp tramp-file-name-regexp)))

(use-package keychain-environment :init (keychain-refresh-environment))
#+END_SRC

** Specific
#+BEGIN_SRC emacs-lisp
(let ((specific (locate-user-emacs-file "specific.el")))
  (when (file-exists-p specific)
    (load specific)))
#+END_SRC

** Emacs server
#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
